<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Word Sketch Lucene Demo</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 30px; }
        .search-box {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        input[type="text"]:focus {
            outline: none;
            border-color: #4a90d9;
        }
        select {
            padding: 12px 16px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            background: #4a90d9;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        button:hover { background: #357abd; }
        button:disabled { background: #ccc; }
        .pos-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .pos-filters label {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            border: 1px solid #ddd;
        }
        .pos-filters input:checked + span {
            font-weight: bold;
            color: #4a90d9;
        }
        .results { display: grid; gap: 20px; }
        .sketch-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .sketch-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .sketch-section .pos-tag {
            background: #e8f4fd;
            color: #4a90d9;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }
        .collocation {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }
        .collocation:last-child { border-bottom: none; }
        .collocation .word { font-weight: 500; }
        .collocation .score {
            color: #666;
            font-size: 14px;
        }
        .collocation .freq { color: #999; font-size: 12px; }
        .examples {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .examples h4 {
            margin: 0 0 10px 0;
            color: #666;
            font-size: 14px;
        }
        .example {
            padding: 8px 12px;
            background: #f9f9f9;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 14px;
        }
        .example .highlight {
            background: #fff3cd;
            padding: 0 2px;
            border-radius: 2px;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            background: #fee;
            color: #c00;
            padding: 20px;
            border-radius: 8px;
        }
        .api-config {
            background: #fff8e0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .api-config label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .api-config input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }
        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 16px;
            color: #666;
        }
        .tab.active {
            color: #4a90d9;
            border-bottom-color: #4a90d9;
            font-weight: 500;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .snowball-controls {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }
        .snowball-controls input,
        .snowball-controls select {
            padding: 12px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        #snowballGraph {
            width: 100%;
            height: 600px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .snowball-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .stat-card h4 {
            margin: 0 0 5px 0;
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-card .value {
            font-size: 28px;
            font-weight: bold;
            color: #4a90d9;
        }
        .radial-button {
            margin-left: auto;
            padding: 6px 10px;
            font-size: 12px;
            background: #f0f5ff;
            color: #357abd;
            border: 1px solid #cfe0ff;
            border-radius: 6px;
            cursor: pointer;
        }
        .radial-button:hover { background: #e4efff; }
        .radial-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .radial-modal.active { display: flex; }
        .radial-content {
            background: white;
            border-radius: 12px;
            width: 880px;
            max-width: 95vw;
            padding: 20px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.2);
        }
        .radial-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .radial-title {
            font-size: 18px;
            font-weight: 600;
            color: #333;
        }
        .radial-subtitle {
            font-size: 13px;
            color: #666;
            margin-bottom: 8px;
        }
        .radial-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
        }
        .radial-legend {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 12px;
            color: #666;
            margin-top: 8px;
        }
        .radial-legend span {
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }
        .radial-legend .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        .radial-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            font-size: 12px;
            color: #666;
        }
        .radial-controls input[type="number"] {
            width: 70px;
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }
        .adj-row { cursor: pointer; }
        .adj-row:hover { background: #f7fbff; }
    </style>
</head>
<body>
    <h1>Word Sketch Lucene</h1>
    <p class="subtitle">Corpus-based collocation analysis powered by Apache Lucene</p>

    <div class="api-config">
        <label>API URL:</label>
        <input type="text" id="apiUrl" value="http://localhost:8080" placeholder="http://localhost:8080">
    </div>

    <div class="tabs">
        <button class="tab active" onclick="switchTab('sketch')">Word Sketch</button>
        <button class="tab" onclick="switchTab('dependency')">Dependency Sketch</button>
        <button class="tab" onclick="switchTab('semantic')">Semantic Field Explorer</button>
        <button class="tab" onclick="switchTab('bcql')">BCQL Query</button>
    </div>

    <div id="sketchTab" class="tab-content active">
        <div class="search-box">
            <input type="text" id="wordInput" placeholder="Enter a word (e.g., 'problem', 'house', 'run')" autofocus>
            <select id="posFilter">
                <option value="">All POS</option>
                <option value="noun">Nouns</option>
                <option value="verb">Verbs</option>
                <option value="adj">Adjectives</option>
                <option value="adv">Adverbs</option>
            </select>
            <button id="searchBtn" onclick="search()">Search</button>
        </div>

        <div class="pos-filters">
            <label><input type="checkbox" checked onchange="filterPos('noun')"> <span>Nouns (n)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('verb')"> <span>Verbs (v)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('adj')"> <span>Adjectives (adj)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('adv')"> <span>Adverbs (adv)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('prep')"> <span>Prepositions (prep)</span></label>
            <label><input type="checkbox" checked onchange="filterPos('part')"> <span>Particles (part)</span></label>
        </div>

        <div id="results" class="results"></div>
    </div>

    <div id="semanticTab" class="tab-content">
        <!-- Mode selector -->
        <div class="pos-filters" style="margin-bottom: 15px;">
            <label><input type="radio" name="semanticMode" value="explore" checked onchange="switchSemanticMode('explore')"> <span>Explore (bootstrap from seed)</span></label>
            <label><input type="radio" name="semanticMode" value="multiexplore" onchange="switchSemanticMode('multiexplore')"> <span>Multi-Seed Explore (cluster of seeds)</span></label>
            <label><input type="radio" name="semanticMode" value="compare" onchange="switchSemanticMode('compare')"> <span>Compare (analyze given nouns)</span></label>
        </div>

        <!-- Explore mode (single seed) -->
        <div id="exploreMode" class="snowball-controls" style="grid-template-columns: 2fr 1.5fr 0.7fr 0.7fr 0.7fr 0.5fr;">
            <input type="text" id="exploreSeed" placeholder="Seed word (e.g., house, car, theory)">
            <select id="exploreRelation" title="Grammatical relation">
                <!-- Populated dynamically from /api/relations -->
            </select>
            <input type="number" id="exploreTopAdj" value="15" min="5" max="30" title="Top collocates to use">
            <input type="number" id="exploreMinShared" value="2" min="1" max="5" title="Min shared collocates">
            <input type="number" id="exploreMinLogDice" value="2.0" step="0.5" min="0" title="Min LogDice">
            <button onclick="runExplore()">Explore</button>
        </div>

        <!-- Multi-Seed Explore mode (hidden by default) -->
        <div id="multiexploreMode" class="snowball-controls" style="display: none; grid-template-columns: 2fr 1.5fr 0.7fr 0.7fr 0.7fr 0.5fr;">
            <input type="text" id="multiExploreSeed" placeholder="Seeds (comma-separated, e.g., theory,model,hypothesis)">
            <select id="multiExploreRelation" title="Grammatical relation">
                <!-- Populated dynamically from /api/relations -->
            </select>
            <input type="number" id="multiExploreTopAdj" value="15" min="5" max="30" title="Top collocates per seed">
            <input type="number" id="multiExploreMinShared" value="2" min="1" max="5" title="Min shared collocates">
            <input type="number" id="multiExploreMinLogDice" value="2.0" step="0.5" min="0" title="Min LogDice">
            <button onclick="runMultiExplore()">Explore</button>
        </div>

        <!-- Compare mode (hidden by default) -->
        <div id="compareMode" class="snowball-controls" style="display: none; grid-template-columns: 2fr 0.8fr 0.8fr 0.5fr;">
            <input type="text" id="semanticNouns" placeholder="Nouns to compare (comma-separated, e.g., theory,model,hypothesis)">
            <input type="number" id="semanticMinLogDice" value="2.0" step="0.5" min="0" placeholder="Min LogDice" title="Minimum LogDice threshold">
            <input type="number" id="semanticMaxPerNoun" value="50" min="10" max="100" placeholder="Max per noun" title="Maximum collocates per noun">
            <button onclick="runSemanticField()">Compare</button>
        </div>
        
        <div id="semanticGraph"></div>
        
        <!-- Examples panel (hidden by default) -->
        <div id="examplesPanel" style="display: none; margin-top: 20px; padding: 15px; background: white; border: 2px solid #3498db; border-radius: 8px;">
            <h3 id="examplesPanelTitle" style="margin-top: 0;">Examples</h3>
            <div id="examplesList"></div>
        </div>
        
        <div class="snowball-stats">
            <div class="stat-card">
                <h4 id="statLabel1">Seed Adjectives</h4>
                <div class="value" id="statFullyShared">-</div>
            </div>
            <div class="stat-card">
                <h4 id="statLabel2">Discovered Nouns</h4>
                <div class="value" id="statPartiallyShared">-</div>
            </div>
            <div class="stat-card">
                <h4 id="statLabel3">Core Adjectives</h4>
                <div class="value" id="statSpecific">-</div>
            </div>
        </div>
        
        <div id="semanticDetails" class="results" style="margin-top: 20px;"></div>
    </div>

    <!-- Dependency Sketch Tab -->
    <div id="dependencyTab" class="tab-content">
        <div class="search-box">
            <input type="text" id="depWordInput" placeholder="Enter a word (e.g., 'theory', 'explain', 'hypothesis')" autofocus>
            <button id="depSearchBtn" onclick="searchDependency()">Search</button>
        </div>

        <!-- Dependency relation filters -->
        <div class="pos-filters" style="margin-bottom: 20px;">
            <label><input type="checkbox" checked onchange="filterDepRel('nsubj')"> <span>Subjects (nsubj)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('obj')"> <span>Objects (obj)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('amod')"> <span>Modifiers (amod)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('advmod')"> <span>Adverbs (advmod)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('nmod')"> <span>Nominal mods (nmod)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('compound')"> <span>Compounds</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('aux')"> <span>Auxiliaries (aux)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('mark')"> <span>Markers (mark)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('det')"> <span>Determiners (det)</span></label>
            <label><input type="checkbox" checked onchange="filterDepRel('case')"> <span>Case markers (case)</span></label>
        </div>

        <!-- Results container -->
        <div id="depResults" class="results"></div>
    </div>

    <!-- BCQL Query Tab -->
    <div id="bcqlTab" class="tab-content">
        <div style="margin-bottom: 20px;">
            <div style="margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">BCQL Query</label>
                <input type="text" id="bcqlInput" placeholder="e.g., [lemma=&quot;theory&quot;] []{0,3} [lemma=&quot;important&quot;]" style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 8px; font-family: monospace;">
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <label for="bcqlLimit">Max results:</label>
                <input type="number" id="bcqlLimit" value="20" min="1" max="100" style="width: 80px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                <button onclick="runBcqlQuery()" style="padding: 12px 24px; font-size: 16px; background: #4a90d9; color: white; border: none; border-radius: 8px; cursor: pointer;">Execute</button>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: #f5f5f5; border-radius: 6px; font-size: 12px; color: #666;">
                <strong>Syntax help:</strong> [lemma="word"] | [tag="JJ.*"] | []{0,5} (0-5 tokens) | {deprel="nsubj"} (dependency)
            </div>
        </div>
        <div id="bcqlResults" class="results"></div>
    </div>

    <div id="radialModal" class="radial-modal" onclick="closeRadial(event)">
        <div class="radial-content" onclick="event.stopPropagation()">
            <div class="radial-header">
                <div class="radial-title" id="radialTitle">Radial Plot</div>
                <div style="display:flex;gap:8px;align-items:center;">
                    <button class="radial-close" onclick="downloadRadialSvg()" title="Download SVG">⬇️ Download</button>
                    <button class="radial-close" onclick="closeRadial(event)">✕</button>
                </div>
            </div>
            <div class="radial-subtitle" id="radialSubtitle"></div>
            <div class="radial-controls">
                <label for="radialCount">Items</label>
                <input type="number" id="radialCount" value="20" min="5" max="100">
            </div>
            <div id="radialSvgContainer" style="width:100%; height:420px; background: white; border-radius: 8px; overflow: auto; display:flex; align-items:center; justify-content:center;"></div>
            <div class="radial-legend" id="radialLegend"></div>
        </div>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Helper function to get API URL with fallback
        function getApiUrl() {
            const el = document.getElementById('apiUrl');
            return el ? el.value.trim() : 'http://localhost:8080';
        }

        let activeFilters = { noun: true, verb: true, adj: true, adv: true, prep: true, part: true, other: true };
        let currentWord = '';
        let currentTab = 'sketch';

        async function search() {
            const word = document.getElementById('wordInput').value.trim();
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const resultsDiv = document.getElementById('results');
            const btn = document.getElementById('searchBtn');

            if (!word) return;

            currentWord = word;
            btn.disabled = true;
            resultsDiv.innerHTML = '<div class="loading">Analyzing "' + word + '"...</div>';

            try {
                // Try different API endpoints
                let data = null;
                let errorMsg = '';

                const selectedPos = document.getElementById('posFilter')?.value || '';
                const posParam = selectedPos ? `?pos=${encodeURIComponent(selectedPos)}` : '';

                // Try the sketch API
                try {
                    const response = await fetch(`${apiUrl}/api/sketch/${word}${posParam}`);
                    if (response.ok) {
                        data = await response.json();
                    } else {
                        errorMsg = `API returned ${response.status}`;
                    }
                } catch (e) {
                    errorMsg = e.message;
                }

                // Fallback: try the problem endpoint
                if (!data) {
                    try {
                        const fallbackPos = selectedPos || 'noun';
                        const response = await fetch(`${apiUrl}/api/sketch/problem?pos=${encodeURIComponent(fallbackPos)}`);
                        if (response.ok) {
                            data = await response.json();
                        }
                    } catch (e) {}
                }

                if (!data) {
                    resultsDiv.innerHTML = `
                        <div class="error">
                            <strong>Could not connect to API</strong><br>
                            Make sure the server is running at: ${apiUrl}<br>
                            <small>${errorMsg}</small>
                        </div>
                    `;
                } else {
                    renderResults(data);
                }
            } catch (e) {
                resultsDiv.innerHTML = `<div class="error">Error: ${e.message}</div>`;
            }

            btn.disabled = false;
        }

        // Populate relation dropdowns from /api/relations
        async function populateRelationDropdowns() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const exploreSelect = document.getElementById('exploreRelation');
            const multiExploreSelect = document.getElementById('multiExploreRelation');

            if (!exploreSelect || !multiExploreSelect) return;

            try {
                const response = await fetch(`${apiUrl}/api/relations`);
                const data = await response.json();

                if (data.relations && Array.isArray(data.relations)) {
                    const options = data.relations.map(rel => {
                        const label = rel.name || rel.id;
                        return `<option value="${rel.id}">${label}</option>`;
                    }).join('');

                    exploreSelect.innerHTML = options;
                    multiExploreSelect.innerHTML = options;
                }
            } catch (e) {
                console.error('Failed to load relations:', e);
                // Fallback to default options if fetch fails
                exploreSelect.innerHTML = `
                    <option value="adj_predicate">X is ADJ (predicate)</option>
                    <option value="adj_modifier">ADJ X (modifier)</option>
                    <option value="subject_of">X VERBs (subject)</option>
                    <option value="object_of">VERB X (object)</option>
                `;
                multiExploreSelect.innerHTML = exploreSelect.innerHTML;
            }
        }

        // Initialize on page load
        populateRelationDropdowns();

        // Fetch examples for semantic field exploration
        async function fetchSemanticFieldExamples(adj, noun, max = 10) {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const detailsDiv = document.getElementById('semanticDetails');

            // Show loading in a modal or inline
            const examplesId = 'semantic-examples-' + adj + '-' + noun;
            let examplesDiv = document.getElementById(examplesId);
            if (examplesDiv) {
                // Toggle visibility if already loaded
                examplesDiv.style.display = examplesDiv.style.display === 'none' ? 'block' : 'none';
                return;
            }

            detailsDiv.insertAdjacentHTML('beforeend', `<div id="${examplesId}" class="examples" style="margin-top:20px; padding:15px; background:#f9f9f9; border-radius:8px;"><div class="loading">Fetching examples for "${adj} ${noun}"...</div></div>`);
            examplesDiv = document.getElementById(examplesId);

            try {
                const response = await fetch(`${apiUrl}/api/semantic-field/examples?adjective=${encodeURIComponent(adj)}&noun=${encodeURIComponent(noun)}&max=${max}`);
                const data = await response.json();

                if (data.examples && data.examples.length > 0) {
                    let html = `<h4 style="margin-top:0;">Examples: "${adj} ${noun}"</h4>`;
                    data.examples.forEach((ex, i) => {
                        // Highlight the adjective and noun in the sentence
                        const highlighted = ex
                            .replace(new RegExp(`\\b${adj}\\b`, 'gi'), '<strong style="color:#e74c3c;">$&</strong>')
                            .replace(new RegExp(`\\b${noun}\\b`, 'gi'), '<strong style="color:#3498db;">$&</strong>');
                        html += `<div class="example">${highlighted}</div>`;
                    });
                    examplesDiv.innerHTML = html;
                } else {
                    examplesDiv.innerHTML = `<div style="color:#888;">No examples found for "${adj} ${noun}".</div>`;
                }
            } catch (e) {
                examplesDiv.innerHTML = `<div class="error">Failed to fetch examples: ${e.message}</div>`;
            }
        }

        function filterPos(pos) {
            activeFilters[pos] = !activeFilters[pos];
            if (currentWord) {
                search();
            }
        }

        // Map frontend relation IDs to API relation IDs
        function mapRelationToApi(relationId) {
            const mapping = {
                'adj_predicate': 'noun_adj_predicates',
                'adj_modifier': 'noun_modifiers',
                'subject_of': 'noun_verbs',
                'object_of': 'verb_nouns'
            };
            return mapping[relationId] || relationId;
        }

        let currentSketchData = null;
        let currentSemanticData = null;
        let currentSemanticAdjMap = {};

        function renderResults(data) {
            const resultsDiv = document.getElementById('results');
            currentSketchData = data;

            if (!data || !data.patterns || Object.keys(data.patterns).length === 0) {
                resultsDiv.innerHTML = `
                    <div class="error">
                        <strong>No results found</strong><br>
                        Try a different word or check the API response.
                    </div>
                `;
                return;
            }

            let html = '';
            let allAutoFetchData = [];

            // Process patterns from the API
            const patterns = data.patterns;

            for (const [patternId, patternData] of Object.entries(patterns)) {
                if (patternData.error) {
                    continue; // Skip patterns with errors
                }
                
                const collocations = patternData.collocations || [];
                if (collocations.length === 0) {
                    continue;
                }
                
                // Determine POS from pattern
                const collocatePosGroup = patternData.collocate_pos_group || patternData.pos_group || 'other';
                if (Object.prototype.hasOwnProperty.call(activeFilters, collocatePosGroup) && !activeFilters[collocatePosGroup]) {
                    continue;
                }
                
                // Render section
                html += `
                    <div class="sketch-section">
                        <h3>
                            ${patternData.name}
                            <span class="pos-tag">${collocatePosGroup.toUpperCase()}</span>
                            <button class="radial-button" onclick="openRadialSketch('${patternId}')">Radial view</button>
                        </h3>
                        <div class="collocation-list">
                `;
                
                // Auto-fetch examples for top 3 collocations
                const topCollocs = collocations.slice(0, 3);
                topCollocs.forEach((c, idx) => {
                    allAutoFetchData.push({
                        id: `example-${patternId}-${idx}`,
                        word1: currentWord,
                        word2: c.lemma,
                        relation: mapRelationToApi(patternId),
                        pos: c.pos || ''
                    });
                });

                collocations.slice(0, 20).forEach((c, idx) => {
                    const score = c.logDice ? c.logDice.toFixed(2) : '-';
                    const freq = c.frequency || '-';
                    const word = c.lemma || '-';
                    const uniqueId = `example-${patternId}-${idx}`;
                    const apiRelation = mapRelationToApi(patternId);
                    // Show examples by default for top 3
                    const showByDefault = idx < 3;
                    html += `
                        <div style="margin-bottom: 10px;">
                            <div class="collocation" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;">
                                <span class="word" style="cursor: pointer; text-decoration: underline; color: #2980b9; font-weight: 500;" onclick="toggleSketchExamples('${uniqueId}', '${escapeJs(currentWord)}', '${escapeJs(word)}', '${escapeJs(apiRelation)}', '${escapeJs(c.pos || '')}')">${escapeHtml(word)}</span>
                                <span>
                                    <span class="score">logDice: ${score}</span>
                                    <span class="freq">(${freq})</span>
                                </span>
                            </div>
                            <div id="${uniqueId}" style="display: ${showByDefault ? 'block' : 'none'}; margin-top: 8px; margin-left: 10px; padding: 10px; background: #fef5e7; border-left: 3px solid #e74c3c; border-radius: 4px;"><div class="loading">Loading examples...</div></div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // Render examples if available
                const firstWithExamples = collocations.find(c => c.examples && c.examples.length > 0);
                if (firstWithExamples && firstWithExamples.examples.length > 0) {
                    html += '<div class="examples"><h4>Examples</h4>';
                    firstWithExamples.examples.slice(0, 5).forEach(ex => {
                        // Handle both string examples and object examples (API returns objects)
                        const exampleText = (typeof ex === 'string') ? ex : (ex.highlighted || ex.raw || ex.sentence || '');
                        const highlighted = escapeHtml(exampleText).replace(
                            new RegExp(escapeRegExp(currentWord), 'gi'),
                            '<span class="highlight">$&</span>'
                        );
                        html += `<div class="example">${highlighted}</div>`;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
            }

            if (html === '') {
                html = '<div class="error">No collocations found for the selected filters.</div>';
            }

            resultsDiv.innerHTML = html;

            // Auto-fetch examples for top collocations
            if (allAutoFetchData && allAutoFetchData.length > 0) {
                allAutoFetchData.forEach((item, idx) => {
                    setTimeout(() => {
                        fetchSketchExamples(item.id, item.word1, item.word2, item.relation, item.pos);
                    }, idx * 200); // Stagger requests to avoid overwhelming the API
                });
            }
        }

        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;');
        }

        function escapeRegExp(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function escapeJs(str) {
            return String(str)
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'");
        }

        function openRadialSketch(patternId) {
            console.log('openRadialSketch called with patternId:', patternId);
            console.log('currentSketchData:', currentSketchData);
            if (!currentSketchData || !currentSketchData.patterns) {
                console.error('No currentSketchData or patterns');
                return;
            }
            const pattern = currentSketchData.patterns[patternId];
            console.log('pattern:', pattern);
            if (!pattern || !pattern.collocations) {
                console.error('No pattern or collocations');
                return;
            }

            const items = pattern.collocations.map(c => ({
                label: c.lemma,
                score: c.logDice || 0,
                meta: `freq ${c.frequency || 0}`,
                color: '#4a90d9'
            }));
            console.log('items:', items);

            showRadialPlot({
                title: `${currentWord || 'Word'} • ${pattern.name}`,
                subtitle: `Pattern: ${pattern.cql}`,
                centerLabel: currentWord || 'word',
                items
            });
        }

        function openRadialAdjective(adjWord) {
            if (!adjWord) return;
            const adj = currentSemanticAdjMap[adjWord.toLowerCase()];
            if (!adj || !currentSemanticData) return;

            const nouns = currentSemanticData.nouns || [];
            const scores = adj.noun_scores || {};
            const items = nouns.map(noun => ({
                label: noun,
                score: scores[noun] || 0,
                meta: scores[noun] ? `logDice ${scores[noun].toFixed(2)}` : 'no match',
                color: '#d94a4a'
            }));

            showRadialPlot({
                title: `${adj.word} • noun profile`,
                subtitle: `Category: ${adj.category} • present in ${adj.present_in}/${adj.total_nouns}`,
                centerLabel: adj.word,
                items
            });
        }

        // Store current plot data for re-rendering when item count changes
        let currentRadialPlot = { title: '', subtitle: '', centerLabel: '', items: [], mode: '' };

        async function renderRadialPlot() {
            const { title, subtitle, centerLabel, items, mode } = currentRadialPlot;
            const modal = document.getElementById('radialModal');
            const container = document.getElementById('radialSvgContainer');
            const legend = document.getElementById('radialLegend');

            container.innerHTML = '<div class="loading">Rendering radial plot...</div>';
            legend.innerHTML = '';

            try {
                const apiUrl = getApiUrl();
                const countInput = document.getElementById('radialCount');
                const maxItems = Math.max(5, Math.min(100, parseInt(countInput?.value || '20', 10)));
                // Use smaller dimensions to fit dialog better
                const payload = { center: centerLabel || '', width: 640, height: 420, items: items.slice(0, maxItems) };
                if (mode) payload.mode = mode;
                const response = await fetch(`${apiUrl}/api/visual/radial`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error(`Server returned ${response.status}`);
                const svgText = await response.text();

                // Insert server-rendered SVG
                container.innerHTML = svgText;

                // Simple legend - use plain text symbols instead of HTML entities
                const maxScore = Math.max(1, ...items.map(i => Math.abs(i.score || 0)));
                legend.innerHTML = mode === 'signed'
                    ? `<span><span class="dot" style="background:rgb(43,131,186)"></span> positive (A>B) &nbsp; <span><span class="dot" style="background:rgb(215,25,28)"></span> negative (B>A)</span>`
                    : `<span><span class="dot" style="background:${items[0]?.color || '#4a90d9'}"></span> max ${maxScore.toFixed(2)}</span>`;

            } catch (err) {
                container.innerHTML = `<div class="error">Failed to render radial plot: ${err.message}</div>`;
            }
        }

        function downloadRadialSvg() {
            const container = document.getElementById('radialSvgContainer');
            const svgElement = container.querySelector('svg');
            if (!svgElement) {
                alert('No radial plot to download');
                return;
            }

            // Get SVG content
            const svgData = new XMLSerializer().serializeToString(svgElement);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            // Create download link
            const link = document.createElement('a');
            link.href = url;
            link.download = `radial-${currentRadialPlot.centerLabel || 'plot'}.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        async function showRadialPlot({ title, subtitle, centerLabel, items, mode }) {
            const modal = document.getElementById('radialModal');

            document.getElementById('radialTitle').textContent = title || 'Radial Plot';
            document.getElementById('radialSubtitle').textContent = subtitle || '';

            // Store plot data for re-rendering when item count changes
            currentRadialPlot = { title, subtitle, centerLabel, items, mode };

            // Set up event listener for radialCount input changes
            const countInput = document.getElementById('radialCount');
            if (countInput && !countInput.dataset.listenerAttached) {
                countInput.addEventListener('change', renderRadialPlot);
                countInput.addEventListener('input', renderRadialPlot);
                countInput.dataset.listenerAttached = 'true';
            }

            // Initial render
            await renderRadialPlot();

            modal.classList.add('active');
        }

        function openRadialCompare(nounA, nounB) {
            // Build items from currentSemanticData adjectives: label=adjective, score = nounA - nounB
            if (!currentSemanticData || !currentSemanticData.adjectives) return;
            const adjectives = currentSemanticData.adjectives || [];
            const items = adjectives.map(adj => ({ label: adj.word, score: (adj.noun_scores?.[nounA] || 0) - (adj.noun_scores?.[nounB] || 0) }));
            showRadialPlot({
                title: `${nounA} vs ${nounB}`,
                subtitle: `Difference in logDice: ${nounA} − ${nounB}`,
                centerLabel: `${nounA} − ${nounB}`,
                items,
                mode: 'signed'
            });
        }

        function closeRadial(event) {
            if (event) {
                event.preventDefault();
            }
            document.getElementById('radialModal').classList.remove('active');
        }

        function switchTab(tabName) {
            currentTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        function switchSemanticMode(mode) {
            document.getElementById('exploreMode').style.display = mode === 'explore' ? 'flex' : 'none';
            document.getElementById('multiexploreMode').style.display = mode === 'multiexplore' ? 'flex' : 'none';
            document.getElementById('compareMode').style.display = mode === 'compare' ? 'flex' : 'none';
            
            // Update stat labels based on mode
            if (mode === 'explore' || mode === 'multiexplore') {
                document.getElementById('statLabel1').textContent = 'Seed Adjectives';
                document.getElementById('statLabel2').textContent = 'Discovered Nouns';
                document.getElementById('statLabel3').textContent = 'Core Adjectives';
            } else {
                document.getElementById('statLabel1').textContent = 'Fully Shared';
                document.getElementById('statLabel2').textContent = 'Partially Shared';
                document.getElementById('statLabel3').textContent = 'Specific';
            }
        }

        async function runExplore() {
            const seed = document.getElementById('exploreSeed').value.trim();
            const relation = document.getElementById('exploreRelation')?.value || 'adj_predicate';
            const topAdj = document.getElementById('exploreTopAdj')?.value || 15;
            const minShared = document.getElementById('exploreMinShared')?.value || 2;
            const minLogDice = document.getElementById('exploreMinLogDice')?.value || 2;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!seed) {
                alert('Please enter a seed word (e.g., house, car, theory)');
                return;
            }
            
            console.log('Exploring:', {seed, relation, topAdj, minShared, minLogDice});
            
            const relationLabels = {
                'adj_predicate': 'X is ADJ',
                'adj_modifier': 'ADJ X',
                'subject_of': 'X VERBs',
                'object_of': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Exploring semantic field from "' + seed + '" (' + relLabel + ')...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const url = `${apiUrl}/api/semantic-field/explore?seed=${encodeURIComponent(seed)}&relation=${relation}&top=${topAdj}&min_shared=${minShared}&min_logdice=${minLogDice}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stat labels based on relation type
                const collocateLabel = (relation === 'subject_of' || relation === 'object_of') ? 'Verbs' : 'Adjectives';
                document.getElementById('statLabel1').textContent = `Seed ${collocateLabel}`;
                document.getElementById('statLabel3').textContent = `Core ${collocateLabel}`;
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.seed_collocates_count || data.seed_adjectives_count || 0;
                document.getElementById('statPartiallyShared').textContent = data.discovered_nouns_count || 0;
                document.getElementById('statSpecific').textContent = data.core_collocates_count || data.core_adjectives_count || 0;
                
                // Visualize exploration results
                visualizeExploration(data, relation);
                
                // Show details panel
                renderExplorationDetails(data);
                
            } catch (e) {
                console.error('Exploration error:', e);
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Semantic field exploration failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                        <small style="display:block; margin-top:5px; color:#999;">Check browser console for details.</small>
                    </div>
                `;
            }
        }

        async function runMultiExplore() {
            const seedsInput = document.getElementById('multiExploreSeed').value.trim();
            const relation = document.getElementById('multiExploreRelation')?.value || 'adj_predicate';
            const topAdj = document.getElementById('multiExploreTopAdj')?.value || 15;
            const minShared = document.getElementById('multiExploreMinShared')?.value || 2;
            const minLogDice = document.getElementById('multiExploreMinLogDice')?.value || 2;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!seedsInput) {
                alert('Please enter seed words (comma-separated, e.g., theory,model,hypothesis)');
                return;
            }
            
            const seeds = seedsInput.split(',').map(s => s.trim().toLowerCase()).filter(s => s);
            if (seeds.length < 2) {
                alert('Please enter at least 2 seed words');
                return;
            }
            
            console.log('Multi-exploring:', {seeds, relation, topAdj, minShared, minLogDice});
            
            const relationLabels = {
                'adj_predicate': 'X is ADJ',
                'adj_modifier': 'ADJ X',
                'subject_of': 'X VERBs',
                'object_of': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Exploring semantic field from ' + seeds.length + ' seeds (' + relLabel + ')...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const seedsParam = seeds.join(',');
                const url = `${apiUrl}/api/semantic-field/explore-multi?seeds=${encodeURIComponent(seedsParam)}&relation=${relation}&top=${topAdj}&min_shared=${minShared}&min_logdice=${minLogDice}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stat labels based on relation type
                const collocateLabel = (relation === 'subject_of' || relation === 'object_of') ? 'Verbs' : 'Adjectives';
                document.getElementById('statLabel1').textContent = `Seed ${collocateLabel}`;
                document.getElementById('statLabel3').textContent = `Core ${collocateLabel}`;
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.common_collocates_count || 0;
                document.getElementById('statPartiallyShared').textContent = data.seed_collocates_count || 0;
                document.getElementById('statSpecific').textContent = data.discovered_nouns_count || 0;
                
                // Visualize multi-seed results
                visualizeMultiExploration(data, relation, seeds);
                
                // Show details panel
                renderMultiExplorationDetails(data, seeds);
                
            } catch (e) {
                console.error('Multi-exploration error:', e);
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Multi-seed exploration failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                        <small style="display:block; margin-top:5px; color:#999;">Check browser console for details.</small>
                    </div>
                `;
            }
        }

        function visualizeExploration(data, relation) {
            const graphDiv = document.getElementById('semanticGraph');
            const isVerb = relation === 'subject_of' || relation === 'object_of';
            const collocateType = isVerb ? 'verb' : 'adjective';
            
            // Build nodes and links for force-directed graph
            const nodes = [];
            const links = [];
            const nodeMap = {};
            
            // Seed node (center)
            const seedNode = { id: data.seed, type: 'seed', group: 0 };
            nodes.push(seedNode);
            nodeMap[data.seed] = seedNode;
            
            // Collocate nodes (from seed) - use seed_collocates or fallback to seed_adjectives
            const seedCollocates = data.seed_collocates || data.seed_adjectives || [];
            seedCollocates.slice(0, 12).forEach((coll, i) => {
                const node = { id: coll.word, type: collocateType, group: 1, logDice: coll.logDice };
                nodes.push(node);
                nodeMap[coll.word] = node;
                links.push({ source: data.seed, target: coll.word, weight: Math.log(coll.logDice) / 5 });
            });
            
            // Discovered noun nodes
            (data.discovered_nouns || []).slice(0, 15).forEach((noun, i) => {
                const node = { id: noun.word, type: 'discovered', group: 2, shared: noun.shared_count, score: noun.similarity_score };
                nodes.push(node);
                nodeMap[noun.word] = node;
                
                // Link to shared collocates
                const sharedCollocates = noun.shared_collocates || noun.shared_adjectives || [];
                sharedCollocates.forEach(coll => {
                    if (nodeMap[coll]) {
                        links.push({ source: coll, target: noun.word, weight: 0.5, dashed: true });
                    }
                });
            });
            
            // Core collocate highlighting
            const coreCollocates = new Set((data.core_collocates || data.core_adjectives || []).map(a => a.word));
            
            // Create SVG
            const width = 840;
            const height = 400;
            
            graphDiv.innerHTML = '';
            const svg = d3.select(graphDiv).append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#fafafa')
                .style('border-radius', '8px');
            
            // Force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(d => 80 - d.weight * 10))
                .force('charge', d3.forceManyBody().strength(-200))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            
            // Draw links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', d => d.dashed ? '#ccc' : '#999')
                .attr('stroke-opacity', d => d.dashed ? 0.4 : 0.6)
                .attr('stroke-width', d => d.weight + 1)
                .attr('stroke-dasharray', d => d.dashed ? '4,4' : null);
            
            // Draw nodes
            const node = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .join('g')
                .call(d3.drag()
                    .on('start', (event, d) => { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; })
                    .on('drag', (event, d) => { d.fx = event.x; d.fy = event.y; })
                    .on('end', (event, d) => { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }));
            
            // Node circles
            node.append('circle')
                .attr('r', d => d.type === 'seed' ? 20 : (d.type === 'adjective' || d.type === 'verb') ? 12 : 15)
                .attr('fill', d => {
                    if (d.type === 'seed') return '#e74c3c';
                    if (d.type === 'adjective' || d.type === 'verb') return coreCollocates.has(d.id) ? '#27ae60' : '#9b59b6';
                    return '#3498db';
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);
            
            // Node labels
            node.append('text')
                .text(d => d.id)
                .attr('dy', d => d.type === 'seed' ? 35 : 25)
                .attr('text-anchor', 'middle')
                .attr('font-size', d => d.type === 'seed' ? '14px' : '11px')
                .attr('font-weight', d => d.type === 'seed' ? 'bold' : 'normal')
                .attr('fill', '#333');
            
            // Shared count badge for discovered nouns
            node.filter(d => d.type === 'discovered')
                .append('text')
                .text(d => d.shared)
                .attr('dy', 4)
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .attr('fill', '#fff');
            
            // Simulation tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Legend - dynamic based on relation type
            const collocateLabel = isVerb ? 'verb' : 'adjective';
            const legend = document.createElement('div');
            legend.className = 'radial-legend';
            legend.innerHTML = `
                <span><span class="dot" style="background:#e74c3c"></span>Seed word</span>
                <span><span class="dot" style="background:#27ae60"></span>Core ${collocateLabel}</span>
                <span><span class="dot" style="background:#9b59b6"></span>Seed ${collocateLabel}</span>
                <span><span class="dot" style="background:#3498db"></span>Discovered noun</span>
            `;
            graphDiv.appendChild(legend);
        }

        function renderExplorationDetails(data) {
            const detailsDiv = document.getElementById('semanticDetails');
            const relation = data.relation_type || 'ADJ_PREDICATE';
            const isVerb = relation === 'SUBJECT_OF' || relation === 'OBJECT_OF';
            const collocateLabel = isVerb ? 'verbs' : 'adjectives';
            const collocateLabelCap = isVerb ? 'Verbs' : 'Adjectives';
            const collocateLabelSingular = isVerb ? 'verb' : 'adjective';
            
            // Get collocates - use generic keys or fallback to adjective-specific keys
            const seedCollocates = data.seed_collocates || data.seed_adjectives || [];
            const coreCollocates = data.core_collocates || data.core_adjectives || [];
            const seedCount = data.seed_collocates_count || data.seed_adjectives_count || 0;
            const coreCount = data.core_collocates_count || data.core_adjectives_count || 0;
            
            const relationLabels = {
                'ADJ_PREDICATE': 'X is ADJ',
                'ADJ_MODIFIER': 'ADJ X',
                'SUBJECT_OF': 'X VERBs',
                'OBJECT_OF': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            
            let html = `
                <div class="sketch-section">
                    <h3>🔍 Exploration from "${data.seed}" <span style="font-size:12px; color:#666; font-weight:normal;">(${relLabel})</span></h3>
                    <p style="color:#666; margin-bottom:15px;">
                        Found <strong>${data.discovered_nouns_count}</strong> similar nouns using 
                        <strong>${seedCount}</strong> ${collocateLabel}.
                        <strong>${coreCount}</strong> ${collocateLabel} define the semantic class.
                    </p>
                    
                    <h4 style="margin-top:20px;">Discovered Semantic Class</h4>
                    <p style="color:#888; font-size:13px;">Nouns that share ${collocateLabelSingular} ${relation === 'ADJ_PREDICATE' ? 'predicates' : 'collocations'} with "${data.seed}"</p>
                    <table style="width:100%; border-collapse:collapse; margin-top:10px;">
                        <tr style="background:#f0f0f0;">
                            <th style="text-align:left; padding:8px;">Noun</th>
                            <th style="text-align:center; padding:8px;">Shared</th>
                            <th style="text-align:right; padding:8px;">Score</th>
                            <th style="text-align:left; padding:8px;">Shared ${collocateLabelCap}</th>
                        </tr>
            `;
            
            (data.discovered_nouns || []).slice(0, 20).forEach(noun => {
                const sharedCollocates = noun.shared_collocates || noun.shared_adjectives || [];
                const firstColloc = sharedCollocates[0] || '';
                html += `
                    <tr class="collocation">
                        <td style="padding:8px; font-weight:500; cursor:pointer;" onclick="document.getElementById('exploreSeed').value='${noun.word}'; runExplore();">${noun.word}</td>
                        <td style="text-align:center; padding:8px;">
                            <span style="background:#3498db; color:white; padding:2px 8px; border-radius:10px; font-size:12px;">${noun.shared_count}</span>
                        </td>
                        <td style="text-align:right; padding:8px; color:#666;">${noun.similarity_score.toFixed(1)}</td>
                        <td style="padding:8px; font-size:12px; color:#888;">${sharedCollocates.slice(0, 5).map(c =>
                            `<span style="cursor:pointer; color:#27ae60;" onclick="event.stopPropagation(); fetchSemanticFieldExamples('${c}', '${noun.word}')">${c}</span>`
                        ).join(', ')}${sharedCollocates.length > 5 ? '...' : ''}</td>
                    </tr>
                `;
            });
            
            html += `</table>`;
            
            // Core collocates section
            html += `
                <h4 style="margin-top:25px;">Core ${collocateLabelCap} (Class Definers)</h4>
                <p style="color:#888; font-size:13px;">${collocateLabelCap} shared by many nouns in this semantic class</p>
                <div style="display:flex; flex-wrap:wrap; gap:10px; margin-top:10px;">
            `;
            
            coreCollocates.forEach(coll => {
                const coverage = Math.round(coll.coverage * 100);
                html += `
                    <div style="background:#e8f8f5; border:1px solid #27ae60; border-radius:20px; padding:6px 12px; font-size:13px; cursor:pointer;" onclick="fetchSemanticFieldExamples('${coll.word}', '${data.seed}')">
                        <strong>${coll.word}</strong>
                        <span style="color:#27ae60; margin-left:5px;">${coverage}%</span>
                    </div>
                `;
            });
            
            html += `</div>`;
            
            // Seed collocates section
            html += `
                <h4 style="margin-top:25px;">Seed ${collocateLabelCap} (from "${data.seed}")</h4>
                <div style="display:flex; flex-wrap:wrap; gap:8px; margin-top:10px;">
            `;
            
            seedCollocates.forEach(coll => {
                const isCore = coreCollocates.some(c => c.word === coll.word);
                html += `
                    <span style="background:${isCore ? '#27ae60' : '#9b59b6'}; color:white; padding:4px 10px; border-radius:15px; font-size:12px;">
                        ${coll.word}
                    </span>
                `;
            });
            
            html += `</div></div>`;
            
            detailsDiv.innerHTML = html;
        }

        function visualizeMultiExploration(data, relation, seeds) {
            const graphDiv = document.getElementById('semanticGraph');
            const isVerb = relation === 'subject_of' || relation === 'object_of';
            const collocateType = isVerb ? 'verb' : 'adjective';
            
            // Build nodes and links for force-directed graph
            const nodes = [];
            const links = [];
            const nodeMap = {};
            
            // Seed nodes (cluster in center)
            seeds.forEach((seed, i) => {
                const seedNode = { id: seed, type: 'seed', group: 0 };
                nodes.push(seedNode);
                nodeMap[seed] = seedNode;
            });
            
            // Collocate nodes (adjectives/verbs around seeds)
            if (data.edges) {
                data.edges.forEach(edge => {
                    // Source is seed, target is collocate
                    if (!nodeMap[edge.target]) {
                        const collocNode = { id: edge.target, type: 'collocate', group: 1 };
                        nodes.push(collocNode);
                        nodeMap[edge.target] = collocNode;
                    }
                    links.push({
                        source: edge.source,
                        target: edge.target,
                        value: edge.weight,
                        type: edge.type
                    });
                });
            }
            
            // Create SVG graph (force-directed)
            const width = graphDiv.offsetWidth;
            const height = 600;
            
            graphDiv.innerHTML = `<svg id="graphSvg" width="${width}" height="${height}" style="border: 1px solid #ddd; border-radius: 8px;"></svg>`;
            
            const svg = d3.select('#graphSvg');
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(60).strength(0.1))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collide', d3.forceCollide(25));
            
            const link = svg.selectAll('line')
                .data(links)
                .enter()
                .append('line')
                .style('stroke', '#999')
                .style('stroke-opacity', 0.6)
                .style('stroke-width', d => Math.log(d.value + 1) * 2);
            
            const node = svg.selectAll('circle')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('r', d => d.type === 'seed' ? 12 : 7)
                .style('fill', d => d.type === 'seed' ? '#FF6B6B' : '#4a90d9')
                .style('stroke', '#fff')
                .style('stroke-width', 2)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            const text = svg.selectAll('text')
                .data(nodes)
                .enter()
                .append('text')
                .attr('dy', '0.31em')
                .attr('text-anchor', 'middle')
                .text(d => d.id)
                .style('font-size', d => d.type === 'seed' ? '12px' : '10px')
                .style('pointer-events', 'none')
                .style('font-weight', d => d.type === 'seed' ? 'bold' : 'normal');
            
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                text
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        function renderMultiExplorationDetails(data, seeds) {
            const detailsDiv = document.getElementById('semanticDetails');
            const relation = data.relation_type || 'ADJ_PREDICATE';
            const isVerb = relation === 'SUBJECT_OF' || relation === 'OBJECT_OF';
            const collocateLabel = isVerb ? 'verbs' : 'adjectives';
            const collocateLabelCap = isVerb ? 'Verbs' : 'Adjectives';
            
            const relationLabels = {
                'ADJ_PREDICATE': 'X is ADJ',
                'ADJ_MODIFIER': 'ADJ X',
                'SUBJECT_OF': 'X VERBs',
                'OBJECT_OF': 'VERB X'
            };
            const relLabel = relationLabels[relation] || relation;
            
            let html = `
                <div class="sketch-section">
                    <h3>🔍 Multi-Seed Exploration <span style="font-size:12px; color:#666; font-weight:normal;">(${relLabel})</span></h3>
                    <p style="color:#666; margin-bottom:15px;">
                        <strong>Seeds:</strong> ${seeds.join(', ')} <br>
                        <strong>${collocateLabelCap} found:</strong> ${data.seed_collocates_count || 0} | 
                        <strong>Common across all:</strong> ${data.common_collocates_count || 0}
                    </p>
            `;
            
            // List seed collocates
            if (data.seed_collocates && data.seed_collocates.length > 0) {
                html += `<div style="margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #333;">Seed ${collocateLabelCap}:</h4>
                    <div>`;
                
                data.seed_collocates.forEach(item => {
                    html += `<div class="collocation">
                        <strong>${item.word}</strong>
                        <span style="color: #666; font-size: 12px;">logDice: ${item.logDice?.toFixed(2) || 'N/A'}</span>
                    </div>`;
                });
                
                html += `</div></div>`;
            }
            
            // List common collocates if any
            if (data.common_collocates && data.common_collocates.length > 0) {
                html += `<div style="margin-bottom: 15px; background: #f0f8ff; padding: 10px; border-radius: 6px; border-left: 4px solid #4a90d9;">
                    <h4 style="margin: 0 0 10px 0; color: #4a90d9;">Common ${collocateLabelCap} (shared by all seeds):</h4>
                    <div>`;
                
                data.common_collocates.forEach(word => {
                    html += `<div class="collocation" style="background: white; margin-bottom: 5px; border-radius: 3px;">
                        <strong>${word}</strong>
                    </div>`;
                });
                
                html += `</div></div>`;
            }
            
            html += `</div>`;
            
            detailsDiv.innerHTML = html;
        }

        async function runSemanticField() {
            const nouns = document.getElementById('semanticNouns')?.value?.trim() || '';
            const minLogDice = document.getElementById('semanticMinLogDice')?.value || 2.0;
            const maxPerNoun = document.getElementById('semanticMaxPerNoun')?.value || 50;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            
            if (!nouns) {
                alert('Please enter nouns to compare (comma-separated, e.g., theory, model, hypothesis)');
                return;
            }
            
            console.log('Comparing nouns:', {nouns, minLogDice, maxPerNoun});
            document.getElementById('semanticGraph').innerHTML = '<div class="loading">Comparing noun profiles: ' + nouns.split(',').map(n => '"' + n.trim() + '"').join(', ') + '...</div>';
            document.getElementById('semanticDetails').innerHTML = '';
            
            try {
                const url = `${apiUrl}/api/semantic-field?nouns=${encodeURIComponent(nouns)}&min_logdice=${minLogDice}&max_per_noun=${maxPerNoun}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                
                const data = await response.json();
                
                // Update stats
                document.getElementById('statFullyShared').textContent = data.fully_shared || 0;
                document.getElementById('statPartiallyShared').textContent = data.partially_shared || 0;
                document.getElementById('statSpecific').textContent = data.specific || 0;
                
                // Visualize graph
                visualizeSemanticField(data);
                
                // Show details panel with graded comparison
                renderSemanticDetails(data);
                
            } catch (e) {
                console.error('Comparison error:', e);
                document.getElementById('semanticGraph').innerHTML = `
                    <div class="error">
                        <strong>Semantic field comparison failed</strong><br>
                        ${e.message}<br>
                        <small>Make sure the API server is running at: ${apiUrl}</small>
                        <small style="display:block; margin-top:5px; color:#999;">Check browser console for details.</small>
                    </div>
                `;
            }
        }

        function renderSemanticDetails(data) {
            const detailsDiv = document.getElementById('semanticDetails');
            const nouns = data.nouns || [];

            currentSemanticData = data;
            currentSemanticAdjMap = {};
            (data.adjectives || []).forEach(adj => {
                if (adj.word) {
                    currentSemanticAdjMap[adj.word.toLowerCase()] = adj;
                }
            });
            
            let html = '';
            
            // Fully shared adjectives
            const fullyShared = (data.adjectives || []).filter(a => a.category === 'fully_shared');
            if (fullyShared.length > 0) {
                html += '<div class="sketch-section"><h3>🟢 Fully Shared (all nouns)</h3>';
                html += renderComparisonTable(fullyShared, nouns);
                html += '</div>';
            }

            // If there are exactly two nouns, add a radial-difference quick button
            if (nouns.length === 2) {
                html += `<div style="margin-top:10px; display:flex; justify-content:flex-end;"><button onclick="openRadialCompare('${nouns[0]}','${nouns[1]}')">Radial: ${nouns[0]} − ${nouns[1]}</button></div>`;
            }
            
            // Partially shared adjectives  
            const partiallyShared = (data.adjectives || []).filter(a => a.category === 'partially_shared');
            if (partiallyShared.length > 0) {
                html += '<div class="sketch-section"><h3>🟡 Partially Shared (2+ nouns)</h3>';
                html += renderComparisonTable(partiallyShared, nouns);
                html += '</div>';
            }
            
            // Specific adjectives - group by noun
            const specific = (data.adjectives || []).filter(a => a.category === 'specific');
            if (specific.length > 0) {
                html += '<div class="sketch-section"><h3>🔵 Specific (one noun only)</h3>';
                
                // Group by the noun they're specific to
                const byNoun = {};
                for (const adj of specific) {
                    const noun = adj.specific_to || '?';
                    if (!byNoun[noun]) byNoun[noun] = [];
                    byNoun[noun].push(adj);
                }
                
                for (const noun of nouns) {
                    if (byNoun[noun] && byNoun[noun].length > 0) {
                        html += `<h4 style="margin: 15px 0 5px 0; color: #666;">Specific to "${noun}":</h4>`;
                        byNoun[noun].slice(0, 10).forEach(adj => {
                            const score = adj.max_logdice || 0;
                            html += `
                                <div class="collocation">
                                    <span class="word">${escapeHtml(adj.word)}</span>
                                    <span class="score">logDice: ${score.toFixed(1)}</span>
                                </div>
                            `;
                        });
                    }
                }
                html += '</div>';
            }
            
            if (!html) {
                html = '<div class="error">No adjectives found. Try lowering min_logdice.</div>';
            }
            
            detailsDiv.innerHTML = html;
        }
        
        function renderComparisonTable(adjectives, nouns) {
            let html = '<table style="width: 100%; border-collapse: collapse; font-size: 14px;">';
            html += '<tr style="background: #f5f5f5;"><th style="text-align: left; padding: 8px;">Adjective</th>';
            for (const noun of nouns) {
                html += `<th style="padding: 8px; text-align: center;">${escapeHtml(noun)}</th>`;
            }
            html += '</tr>';
            
            adjectives.slice(0, 20).forEach(adj => {
                const adjSafe = escapeJs(adj.word || '');
                html += `<tr class="adj-row" onclick="openRadialAdjective('${adjSafe}')" style="border-bottom: 1px solid #eee;">`;
                html += `<td style="padding: 8px; font-weight: 500;">${escapeHtml(adj.word)}</td>`;
                
                const scores = adj.noun_scores || {};
                for (const noun of nouns) {
                    const score = scores[noun] || 0;
                    const intensity = score > 0 ? Math.min(1, score / 10) : 0;
                    const bgColor = score > 0 
                        ? `rgba(74, 144, 217, ${intensity * 0.3})` 
                        : '#f9f9f9';
                    html += `<td style="padding: 8px; text-align: center; background: ${bgColor};">`;
                    html += score > 0 ? score.toFixed(1) : '-';
                    html += '</td>';
                }
                html += '</tr>';
            });
            
            html += '</table>';
            return html;
        }

        async function toggleSketchExamples(uniqueId, word1, word2, relation, collocatePos) {
            const container = document.getElementById(uniqueId);
            if (!container) return;
            
            // If already showing, toggle off
            if (container.style.display !== 'none') {
                container.style.display = 'none';
                return;
            }
            
            // Show loading
            container.innerHTML = '<div class="loading">Fetching examples...</div>';
            container.style.display = 'block';
            
            await fetchSketchExamples(uniqueId, word1, word2, relation, collocatePos);
        }

        async function fetchSketchExamples(containerId, word1, word2, relation, collocatePos) {
            // Fetch examples for Word Sketch tab (inline)
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const container = document.getElementById(containerId);
            
            if (!container) return;
            
            try {
                const relationParam = relation ? `&relation=${encodeURIComponent(relation)}` : '';
                const posParam = collocatePos ? `&collocate_pos=${encodeURIComponent(collocatePos)}` : '';
                const url = `${apiUrl}/api/concordance/examples?word1=${encodeURIComponent(word1)}&word2=${encodeURIComponent(word2)}&limit=10${relationParam}${posParam}`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.examples && data.examples.length > 0) {
                    let html = `<div style="font-size: 12px; color: #555; margin-bottom: 8px;"><strong>${data.count} examples found</strong></div>`;
                    html += data.examples.map((ex, i) => {
                        const displayText = ex.highlighted || ex.raw || ex.sentence;
                        return `<div style="margin: 6px 0; padding: 6px; background: white; border-radius: 3px; font-family: monospace; font-size: 12px; line-height: 1.4;">
                            ${displayText}
                        </div>`;
                    }).join('');
                    
                    if (data.count >= 10) {
                        html += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">
                            <button onclick="alert('Load more not yet implemented')" style="width: 100%; padding: 6px; font-size: 12px;">Load More (${data.count} total)</button>
                        </div>`;
                    }
                    container.innerHTML = html;
                } else {
                    container.innerHTML = '<div style="color: #999; font-size: 12px;">No examples found for this combination.</div>';
                }
                
            } catch (error) {
                container.innerHTML = `<div class="error" style="font-size: 12px;">Failed to fetch examples: ${error.message}</div>`;
            }
        }

        async function fetchExamples(word1, word2) {
            // Ensure we have valid words (not objects)
            const w1 = typeof word1 === 'object' ? word1.id : word1;
            const w2 = typeof word2 === 'object' ? word2.id : word2;
            
            // Hide panel during loading
            const panel = document.getElementById('examplesPanel');
            const titleEl = document.getElementById('examplesPanelTitle');
            const listEl = document.getElementById('examplesList');
            
            titleEl.textContent = `Examples: "${w1}" + "${w2}" (loading...)`;
            listEl.innerHTML = '<div class="loading">Fetching examples...</div>';
            panel.style.display = 'block';
            
            try {
                // Try concordance endpoint first (general case)
                const url = `${apiUrl}/api/concordance/examples?word1=${encodeURIComponent(w1)}&word2=${encodeURIComponent(w2)}&limit=10`;
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Update title
                titleEl.textContent = `Concordance: "${w1}" + "${w2}" (${data.count} found)`;
                
                // Display examples
                if (data.examples && data.examples.length > 0) {
                    listEl.innerHTML = data.examples.map((ex, i) => {
                        // Use highlighted version if available, otherwise use raw sentence
                        const displayText = ex.highlighted || ex.raw || ex.sentence;
                        return `<div style="margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 4px; font-family: monospace; font-size: 13px; line-height: 1.5;">
                            <strong>${i + 1}.</strong> <span style="margin-left: 6px;">${displayText}</span>
                        </div>`;
                    }).join('');
                    
                    // Add "Load more" button if there are more examples available
                    if (data.count >= 10) {
                        listEl.innerHTML += `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
                            <button onclick="fetchExamples('${w1}', '${w2}'); document.getElementById('examplesList').setAttribute('data-limit', '20');" style="width: 100%; padding: 8px;">
                                Load More Examples
                            </button>
                        </div>`;
                    }
                } else {
                    listEl.innerHTML = '<div style="color: #999;">No examples found for this combination.</div>';
                }
                
            } catch (error) {
                titleEl.textContent = `Examples: "${w1}" + "${w2}" (error)`;
                listEl.innerHTML = `<div class="error">Failed to fetch examples: ${error.message}</div>`;
            }
        }

        function highlightWords(sentence, word1, word2) {
            // Simple highlighting - case-insensitive
            const regex1 = new RegExp(`\\b${word1}\\w*`, 'gi');
            const regex2 = new RegExp(`\\b${word2}\\w*`, 'gi');
            
            return sentence
                .replace(regex1, '<mark style="background: #3498db; color: white; padding: 2px 4px; border-radius: 2px;">$&</mark>')
                .replace(regex2, '<mark style="background: #d94a4a; color: white; padding: 2px 4px; border-radius: 2px;">$&</mark>');
        }

        function visualizeSemanticField(data) {
            const container = document.getElementById('semanticGraph');
            container.innerHTML = '';
            
            const width = container.clientWidth;
            const height = 600;
            
            // Create SVG
            const svg = d3.select('#semanticGraph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Prepare graph data
            const nodes = [];
            const links = [];
            const nounList = data.nouns || [];
            
            // Add nouns as nodes (positioned around center)
            nounList.forEach((noun, i) => {
                nodes.push({
                    id: noun,
                    type: 'noun',
                    isSeed: true
                });
            });
            
            // Add adjectives as nodes - use category for coloring
            (data.adjectives || []).forEach(adj => {
                nodes.push({
                    id: adj.word,
                    type: 'adjective',
                    category: adj.category,
                    presentIn: adj.present_in,
                    totalNouns: adj.total_nouns,
                    commonalityScore: adj.commonality_score
                });
            });
            
            // Add edges as links
            (data.edges || []).forEach(edge => {
                links.push({
                    source: edge.source,
                    target: edge.target,
                    logDice: edge.logDice
                });
            });
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            
            // Draw links
            const link = svg.append('g')
                .selectAll('line')
                .data(links)
                .join('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', d => Math.min(1, d.logDice / 10))
                .attr('stroke-width', d => Math.max(1, d.logDice / 3))
                .attr('cursor', 'pointer')
                .on('click', function(event, d) {
                    // Fetch examples when clicking on an edge
                    fetchExamples(d.source.id, d.target.id);
                });
            
            // Draw nodes - color by category
            const node = svg.append('g')
                .selectAll('circle')
                .data(nodes)
                .join('circle')
                .attr('r', d => {
                    if (d.type === 'noun') return 12;
                    // Adjectives sized by presentIn count
                    return 4 + (d.presentIn || 1) * 2;
                })
                .attr('fill', d => {
                    if (d.type === 'noun') {
                        return '#d94a4a';  // Nouns in red
                    }
                    // Color adjectives by category
                    if (d.category === 'fully_shared') return '#2ecc71';   // Green
                    if (d.category === 'partially_shared') return '#f1c40f'; // Yellow
                    return '#3498db';  // Blue for specific
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .attr('cursor', 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add labels
            const label = svg.append('g')
                .selectAll('text')
                .data(nodes)
                .join('text')
                .text(d => d.id)
                .attr('font-size', d => d.type === 'noun' ? 13 : 10)
                .attr('font-weight', d => (d.type === 'noun' || d.category === 'fully_shared') ? 'bold' : 'normal')
                .attr('dx', 12)
                .attr('dy', 4);
            
            // Add tooltips
            node.append('title')
                .text(d => {
                    if (d.type === 'noun') return d.id + ' (noun)';
                    const cat = d.category === 'fully_shared' ? 'all nouns' 
                        : d.category === 'partially_shared' ? 'some nouns' : 'specific';
                    return `${d.id} (${cat}, ${d.presentIn}/${d.totalNouns})`;
                });
            
            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);
                
                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
            
            // Drag functions
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
        }

        // Enter key to search
        document.getElementById('wordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') search();
        });
        
        // Enter key for semantic field
        document.getElementById('semanticNouns').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') runSemanticField();
        });

        // BCQL Query functions
        async function runBcqlQuery() {
            const bcql = document.getElementById('bcqlInput').value.trim();
            const limit = parseInt(document.getElementById('bcqlLimit').value) || 20;
            const apiUrl = document.getElementById('apiUrl').value.trim();
            const resultsDiv = document.getElementById('bcqlResults');

            if (!bcql) {
                resultsDiv.innerHTML = '<div class="error">Please enter a BCQL query</div>';
                return;
            }

            resultsDiv.innerHTML = '<div class="loading">Executing BCQL query...</div>';

            try {
                const response = await fetch(`${apiUrl}/api/bcql`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ query: bcql, limit: limit })
                });
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.error) {
                    resultsDiv.innerHTML = `<div class="error"><strong>Query Error:</strong> ${data.error}</div>`;
                    return;
                }

                // Render results - grouped collocations with logDice
                let html = `<div style="margin-bottom: 15px; padding: 10px; background: #e8f5e9; border-radius: 6px;">
                    <strong>${data.hits || 0}</strong> hits found
                </div>`;

                if (data.results && data.results.length > 0) {
                    // Check if this is grouped results (has collocateLemma) or raw concordances
                    const hasCollocate = data.results[0] && data.results[0].collocateLemma;

                    if (hasCollocate) {
                        // Grouped results with logDice
                        data.results.forEach((result, idx) => {
                            const collocate = result.collocateLemma || '';
                            const freq = result.frequency || 0;
                            const logDice = result.logDice || 0;
                            const sentence = result.sentence || '';

                            const rawXml = result.raw || '';
                            html += `<div style="margin-bottom: 15px; padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #4caf50;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <span style="font-weight: bold; font-size: 16px; color: #2e7d32;">${escapeHtml(collocate)}</span>
                                    <span style="background: #e8f5e9; padding: 4px 8px; border-radius: 4px; font-size: 12px;">
                                        logDice: <strong>${logDice.toFixed(2)}</strong>
                                    </span>
                                </div>
                                <div style="color: #666; font-size: 12px; margin-bottom: 8px;">
                                    Frequency: ${freq}
                                </div>
                                ${sentence ? `<div style="font-family: monospace; font-size: 13px; color: #333; padding: 8px; background: #f5f5f5; border-radius: 4px;">${escapeHtml(sentence)}</div>` : ''}
                                ${rawXml ? `<details style="margin-top: 8px;"><summary style="cursor: pointer; font-size: 11px; color: #999; user-select: none;">Raw XML</summary><pre style="margin: 6px 0 0; padding: 8px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 4px; font-size: 11px; overflow-x: auto; white-space: pre-wrap; word-break: break-all; color: #555;">${escapeHtml(rawXml)}</pre></details>` : ''}
                            </div>`;
                        });
                    } else {
                        // Raw concordances (legacy format)
                        data.results.forEach((result, idx) => {
                            const sentence = result.sentence || '';
                            const matchStart = result.matchStart || 0;
                            const matchEnd = result.matchEnd || 0;

                            // Highlight the match
                            let highlighted = '';
                            if (matchStart >= 0 && matchEnd > matchStart) {
                                highlighted = escapeHtml(sentence.substring(0, matchStart)) +
                                    '<mark style="background: #ffeb3b; padding: 2px;">' +
                                    escapeHtml(sentence.substring(matchStart, matchEnd)) +
                                    '</mark>' +
                                    escapeHtml(sentence.substring(matchEnd));
                            } else {
                                highlighted = escapeHtml(sentence);
                            }

                            html += `<div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px; border-left: 3px solid #4a90d9; font-family: monospace; font-size: 13px; line-height: 1.5;">
                                <div style="color: #666; font-size: 11px; margin-bottom: 5px;">#${idx + 1}</div>
                                ${highlighted}
                            </div>`;
                        });
                    }
                } else {
                    html += '<div style="color: #666;">No matches found.</div>';
                }

                resultsDiv.innerHTML = html;

            } catch (error) {
                resultsDiv.innerHTML = `<div class="error">Error: ${error.message}</div>`;
            }
        }

        // Enter key for BCQL query
        document.getElementById('bcqlInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') runBcqlQuery();
        });

        // Dependency Sketch functions
        let currentDepWord = '';
        let activeDepFilters = {
            nsubj: true, obj: true, amod: true, advmod: true,
            nmod: true, compound: true, aux: true, mark: true,
            det: true, case: true, cop: true, cc: true
        };
        let currentDepRadialData = { relationId: '', lemma: '' };

        async function searchDependency() {
            const word = document.getElementById('depWordInput').value.trim();
            const apiUrl = getApiUrl();
            const resultsDiv = document.getElementById('depResults');
            const btn = document.getElementById('depSearchBtn');

            if (!word) return;

            currentDepWord = word;
            btn.disabled = true;
            resultsDiv.innerHTML = '<div class="loading">Analyzing dependency relations for "' + word + '"...</div>';

            try {
                const response = await fetch(`${apiUrl}/api/sketch/${word}/dep`);
                if (!response.ok) {
                    throw new Error(`API returned ${response.status}`);
                }
                const data = await response.json();
                renderDependencyResults(data);
            } catch (e) {
                resultsDiv.innerHTML = `<div class="error">Error: ${e.message}</div>`;
            }

            btn.disabled = false;
        }

        function renderDependencyResults(data) {
            const resultsDiv = document.getElementById('depResults');

            if (!data.relations || Object.keys(data.relations).length === 0) {
                resultsDiv.innerHTML = '<div class="error">No dependency relations found</div>';
                return;
            }

            let html = '';
            for (const [relId, relData] of Object.entries(data.relations)) {
                // Check if this relation type is filtered
                const deprel = relData.deprel || extractDeprelFromId(relId);
                if (!activeDepFilters[deprel]) continue;

                html += `
                    <div class="sketch-section" data-rel-id="${relId}">
                        <h3>
                            ${relData.name || relId}
                            <span class="pos-tag">${deprel}</span>
                            <button class="radial-button" onclick="showDepRadial('${relId}', '${data.lemma}')">
                                📊 Radial Plot
                            </button>
                        </h3>
                        <p style="color: #666; font-size: 14px; margin-bottom: 10px;">
                            ${relData.description || ''}
                        </p>
                        <div class="collocations">
                `;

                // Render collocates - store data for radial plot
                const collocates = relData.collocations || [];
                const collocatesData = JSON.stringify(collocates).replace(/"/g, '&quot;');
                for (const coll of collocates.slice(0, 20)) {
                    html += `
                        <div class="collocation adj-row"
                             onclick="showDepExamples('${data.lemma}', '${coll.lemma}', '${relId}')">
                            <span class="word">${coll.lemma}</span>
                            <span class="score">logDice: ${coll.logDice.toFixed(2)}</span>
                            <span class="freq">freq: ${coll.frequency}</span>
                        </div>
                    `;
                }

                html += `
                        </div>
                        <div class="dep-relation-examples" id="dep-examples-${relId}" style="display:none;"></div>
                    </div>
                `;
            }

            resultsDiv.innerHTML = html;
        }

        async function showDepExamples(headword, collocate, relationId) {
            const apiUrl = getApiUrl();
            
            // Hide all other example divs first
            document.querySelectorAll('.dep-relation-examples').forEach(div => {
                if (div.id !== `dep-examples-${relationId}`) {
                    div.style.display = 'none';
                }
            });
            
            // Get or create examples div for this relation
            let examplesDiv = document.getElementById(`dep-examples-${relationId}`);
            if (!examplesDiv) {
                // Create it if it doesn't exist
                const relSection = document.querySelector(`.sketch-section[data-rel-id="${relationId}"]`);
                if (relSection) {
                    examplesDiv = document.createElement('div');
                    examplesDiv.id = `dep-examples-${relationId}`;
                    examplesDiv.className = 'dep-relation-examples';
                    examplesDiv.style.display = 'none';
                    relSection.querySelector('.collocations').insertAdjacentElement('afterend', examplesDiv);
                } else {
                    return;
                }
            }

            if (examplesDiv.style.display === 'block') {
                examplesDiv.style.display = 'none';
                return;
            }

            examplesDiv.innerHTML = '<div class="loading">Loading examples...</div>';
            examplesDiv.style.display = 'block';

            try {
                const response = await fetch(
                    `${apiUrl}/api/concordance/examples?word1=${encodeURIComponent(headword)}&word2=${encodeURIComponent(collocate)}&limit=10`
                );
                const data = await response.json();

                if (data.examples && data.examples.length > 0) {
                    const deprel = extractDeprelFromId(relationId);
                    let html = `<h4 style="margin-top:0;">Examples: "${headword}" → "${collocate}" <span style="color:#666;font-weight:normal;font-size:13px;">(${deprel})</span></h4>`;
                    for (const ex of data.examples) {
                        html += `<div class="example">${ex.highlighted}</div>`;
                    }
                    examplesDiv.innerHTML = html;
                } else {
                    examplesDiv.innerHTML = '<div style="color:#888;">No examples found in corpus</div>';
                }
            } catch (e) {
                examplesDiv.innerHTML = `<div class="error">Failed to load examples: ${e.message}</div>`;
            }
        }

        function filterDepRel(deprel) {
            activeDepFilters[deprel] = !activeDepFilters[deprel];
            if (currentDepWord) {
                searchDependency();
            }
        }

        function extractDeprelFromId(relId) {
            // Extract deprel from relation ID like "dep_nsubj" -> "nsubj"
            if (relId.startsWith('dep_')) {
                return relId.substring(4);
            }
            // Fallback: try to extract any deprel-like pattern
            const match = relId.match(/dep[_-]?([a-z]+)/i);
            if (match) {
                return match[1].toLowerCase();
            }
            return 'other';
        }

        function showDepRadial(relationId, lemma) {
            // Store current radial data for re-rendering
            currentDepRadialData = { relationId, lemma };

            // Fetch dependency data and render radial plot
            const apiUrl = getApiUrl();
            const modal = document.getElementById('radialModal');
            const title = document.getElementById('radialTitle');
            const subtitle = document.getElementById('radialSubtitle');
            const svgContainer = document.getElementById('radialSvgContainer');
            const radialCount = document.getElementById('radialCount');
            const legend = document.getElementById('radialLegend');

            // Show modal with loading state
            title.textContent = 'Loading...';
            subtitle.textContent = `Dependency relation: ${relationId}`;
            svgContainer.innerHTML = '<div class="loading">Generating radial plot...</div>';
            modal.classList.add('active');

            // Fetch dependency sketch data
            fetch(`${apiUrl}/api/sketch/${encodeURIComponent(lemma)}/dep/${relationId}`)
                .then(res => res.json())
                .then(data => {
                    const collocates = data.collocations || [];
                    if (collocates.length === 0) {
                        svgContainer.innerHTML = '<div style="color:#666;">No data available for radial plot</div>';
                        return;
                    }

                    // Prepare items for radial plot
                    const count = parseInt(radialCount.value) || 20;
                    const items = collocates.slice(0, count).map(c => ({
                        label: c.lemma,
                        score: c.logDice
                    }));

                    // Update title
                    title.textContent = `"${lemma}" - ${relationId}`;
                    subtitle.textContent = `${collocates.length} collocates by logDice score`;

                    // Build legend with color coding
                    const deprel = extractDeprelFromId(relationId);
                    legend.innerHTML = `
                        <span><span class="dot" style="background:#4a90d9;"></span>Head: ${lemma}</span>
                        <span><span class="dot" style="background:#e74c3c;"></span>Deprel: ${deprel}</span>
                        <span><span class="dot" style="background:#27ae60;"></span>Dependents: ${items.length} shown</span>
                    `;

                    // Call radial plot API for dependency sketch
                    renderDepRadialPlot(apiUrl, lemma, items);
                })
                .catch(err => {
                    svgContainer.innerHTML = `<div class="error">Failed to fetch data: ${err.message}</div>`;
                });
        }

        function renderDepRadialPlot(apiUrl, lemma, items) {
            const svgContainer = document.getElementById('radialSvgContainer');

            // Use smaller dimensions to fit dialog better
            const radialBody = JSON.stringify({
                center: lemma,
                width: 640,
                height: 420,
                items: items,
                mode: 'signed'
            });

            fetch(`${apiUrl}/api/visual/radial`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: radialBody
            })
            .then(res => res.text())
            .then(svg => {
                document.getElementById('radialSvgContainer').innerHTML = svg;
            })
            .catch(err => {
                svgContainer.innerHTML = `<div class="error">Failed to render radial: ${err.message}</div>`;
            });
        }

        // Re-render radial when count changes
        document.getElementById('radialCount')?.addEventListener('change', function() {
            // Trigger re-render by calling showDepRadial again if modal is open
            if (document.getElementById('radialModal').classList.contains('active') && currentDepRadialData.relationId) {
                showDepRadial(currentDepRadialData.relationId, currentDepRadialData.lemma);
            }
        });

        // Enter key for dependency sketch search
        document.getElementById('depWordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') searchDependency();
        });
    </script>
</body>
</html>
