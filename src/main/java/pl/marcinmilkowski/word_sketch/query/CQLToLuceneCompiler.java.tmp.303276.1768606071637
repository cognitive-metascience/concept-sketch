package pl.marcinmilkowski.word_sketch.query;

import org.apache.lucene.index.Term;
import org.apache.lucene.search.MultiTermQuery;
import org.apache.lucene.search.PrefixQuery;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.WildcardQuery;
import org.apache.lucene.queries.spans.SpanFirstQuery;
import org.apache.lucene.queries.spans.SpanMultiTermQueryWrapper;
import org.apache.lucene.queries.spans.SpanNearQuery;
import org.apache.lucene.queries.spans.SpanNotQuery;
import org.apache.lucene.queries.spans.SpanOrQuery;
import org.apache.lucene.queries.spans.SpanQuery;
import org.apache.lucene.queries.spans.SpanTermQuery;
import pl.marcinmilkowski.word_sketch.grammar.CQLPattern;

import java.util.ArrayList;
import java.util.List;

/**
 * Compiler that translates CQL patterns to Lucene SpanQueries.
 */
public class CQLToLuceneCompiler {

    private static final String FIELD_TAG = "tag";
    private static final String FIELD_WORD = "word";
    private static final String FIELD_LEMMA = "lemma";
    private static final String FIELD_POS_GROUP = "pos_group";

    /**
     * Compile a CQL pattern to a Lucene SpanQuery.
     */
    public SpanQuery compile(CQLPattern pattern) {
        List<CQLPattern.PatternElement> elements = pattern.getElements();

        if (elements.isEmpty()) {
            throw new IllegalArgumentException("CQL pattern has no elements");
        }

        if (elements.size() == 1) {
            return buildQuery(elements.get(0));
        }

        List<SpanQuery> spanQueries = new ArrayList<>();
        for (CQLPattern.PatternElement element : elements) {
            spanQueries.add(buildQuery(element));
        }

        int slop = calculateTotalSlop(elements);
        boolean inOrder = true;

        SpanQuery[] clauses = spanQueries.toArray(new SpanQuery[0]);
        return new SpanNearQuery(clauses, slop, inOrder);
    }

    private SpanQuery buildQuery(CQLPattern.PatternElement element) {
        String target = element.getTarget();
        String field = determineField(target);

        SpanQuery query;

        if (element.isLabeled()) {
            SpanQuery baseQuery = buildTermQuery(target, field);
            query = new SpanFirstQuery(baseQuery, element.getPosition());
        } else {
            query = buildTermQuery(target, field);
        }

        if (element.getConstraint() != null) {
            query = applyConstraint(query, element.getConstraint());
        }

        return query;
    }

    private SpanQuery buildTermQuery(String target, String field) {
        target = target.replace("\"", "");

        // Check if it contains regex metacharacters
        if (containsRegexMetacharacters(target)) {
            String wildcard = convertRegexToWildcard(target);
            MultiTermQuery mtq = new WildcardQuery(new Term(field, wildcard));
            return new SpanMultiTermQueryWrapper<>(mtq);
        }

        // Handle prefix patterns like N.*
        if (target.endsWith(".*")) {
            String prefix = target.substring(0, target.length() - 2);
            MultiTermQuery mtq = new WildcardQuery(new Term(field, prefix + "*"));
            return new SpanMultiTermQueryWrapper<>(mtq);
        }

        // Exact match
        return new SpanTermQuery(new Term(field, target));
    }

    /**
     * Convert a simple regex pattern to Lucene wildcard syntax.
     * Handles common patterns like N.*, JJ.*, V.* etc.
     */
    private String convertRegexToWildcard(String regex) {
        if (regex.startsWith("N.*") || regex.startsWith("V.*") ||
            regex.startsWith("J.*") || regex.startsWith("R.*")) {
            String prefix = regex.substring(0, 1);
            return prefix + "*";
        }
        return regex.replace(".*", "*").replace("?", "?");
    }

    private String determineField(String target) {
        target = target.replace("\"", "");

        if (target.matches("^[A-Z].*") || target.matches("^\".*\"")) {
            return FIELD_TAG;
        }

        return FIELD_LEMMA;
    }

    private SpanQuery applyConstraint(SpanQuery baseQuery, CQLPattern.Constraint constraint) {
        if (constraint.isOr()) {
            List<SpanQuery> orQueries = new ArrayList<>();
            orQueries.add(baseQuery);

            for (CQLPattern.Constraint orConstraint : constraint.getOrConstraints()) {
                orQueries.add(buildConstraintQuery(orConstraint));
            }

            return new SpanOrQuery(orQueries.toArray(new SpanQuery[0]));
        }

        return buildConstraintQuery(constraint);
    }

    private SpanQuery buildConstraintQuery(CQLPattern.Constraint constraint) {
        String field = constraint.getField();
        String pattern = constraint.getPattern().replace("\"", "");

        SpanQuery query;

        switch (field.toLowerCase()) {
            case "tag":
                if (containsRegexMetacharacters(pattern)) {
                    String wildcard = convertRegexToWildcard(pattern);
                    MultiTermQuery mtq = new WildcardQuery(new Term(FIELD_TAG, wildcard));
                    query = new SpanMultiTermQueryWrapper<>(mtq);
                } else {
                    query = new SpanTermQuery(new Term(FIELD_TAG, pattern));
                }
                break;
            case "word":
                if (containsRegexMetacharacters(pattern)) {
                    String wildcard = convertRegexToWildcard(pattern);
                    MultiTermQuery mtq = new WildcardQuery(new Term(FIELD_WORD, wildcard));
                    query = new SpanMultiTermQueryWrapper<>(mtq);
                } else {
                    query = new SpanTermQuery(new Term(FIELD_WORD, pattern));
                }
                break;
            case "lemma":
                if (containsRegexMetacharacters(pattern)) {
                    String wildcard = convertRegexToWildcard(pattern);
                    MultiTermQuery mtq = new WildcardQuery(new Term(FIELD_LEMMA, wildcard));
                    query = new SpanMultiTermQueryWrapper<>(mtq);
                } else {
                    query = new SpanTermQuery(new Term(FIELD_LEMMA, pattern));
                }
                break;
            case "pos_group":
                query = new SpanTermQuery(new Term(FIELD_POS_GROUP, pattern));
                break;
            default:
                throw new IllegalArgumentException("Unknown constraint field: " + field);
        }

        if (constraint.isNegated()) {
            return new SpanNotQuery(query, query);
        }

        return query;
    }

    private int calculateTotalSlop(List<CQLPattern.PatternElement> elements) {
        int totalSlop = 0;
        for (CQLPattern.PatternElement element : elements) {
            if (element.getMaxDistance() > 0) {
                totalSlop += element.getMaxDistance();
            }
        }
        return totalSlop;
    }

    private boolean containsRegexMetacharacters(String s) {
        return s.contains(".*") || s.contains(".") ||
               s.contains("[") || s.contains("]") ||
               s.contains("(") || s.contains(")") ||
               s.contains("?") || s.contains("+") ||
               s.contains("^") || s.contains("$") ||
               s.contains("|");
    }
}
