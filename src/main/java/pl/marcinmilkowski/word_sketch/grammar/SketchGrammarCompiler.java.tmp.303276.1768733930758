package pl.marcinmilkowski.word_sketch.grammar;

import org.apache.lucene.queries.spans.SpanQuery;
import pl.marcinmilkowski.word_sketch.query.CQLToLuceneCompiler;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Compiler that converts a SketchGrammar to executable Lucene queries.
 *
 * Handles:
 * - Grammar directive translation (*DUAL, *TRINARY, *UNIMAP, etc.)
 * - Bidirectional relation expansion
 * - Trinary pattern handling
 * - Lemma substitution validation
 * - Agreement rule integration
 */
public class SketchGrammarCompiler {

    private final CQLToLuceneCompiler cqlCompiler;
    private final Map<String, List<SpanQuery>> compiledRelations;

    public SketchGrammarCompiler() {
        this.cqlCompiler = new CQLToLuceneCompiler();
        this.compiledRelations = new HashMap<>();
    }

    /**
     * Compile a sketch grammar into executable queries.
     */
    public CompiledSketch compile(SketchGrammarParser.SketchGrammar grammar) {
        List<CompiledRelation> relations = new ArrayList<>();

        for (SketchGrammarParser.SketchRelation rel : grammar.getRelations()) {
            CompiledRelation compiled = compileRelation(rel, grammar);
            relations.add(compiled);

            // Store for later lookup
            List<SpanQuery> queries = compiled.getQueries();
            compiledRelations.put(rel.getName(), queries);
        }

        return new CompiledSketch(relations, grammar.getDefaultAttr());
    }

    /**
     * Compile a single relation.
     */
    private CompiledRelation compileRelation(SketchGrammarParser.SketchRelation rel,
                                            SketchGrammarParser.SketchGrammar grammar) {
        List<SpanQuery> queries = new ArrayList<>();

        // Get the pattern
        CQLParser.ParsedCQL pattern = rel.getPattern();

        // Handle different relation types
        switch (rel.getType()) {
            case DUAL:
                // Bidirectional: also compile the reverse
                queries.addAll(compilePatternWithExpansion(pattern, rel, true));
                break;

            case TRINARY:
                // Trinary: handle three-position patterns
                queries.addAll(compileTrinaryPattern(pattern, rel));
                break;

            case UNARY:
                // Unary: single element patterns
                queries.addAll(compileUnaryPattern(pattern, rel));
                break;

            case UNIMAP:
                // Unimap: symmetric, map to same name
                queries.addAll(compilePatternWithExpansion(pattern, rel, false));
                break;

            default:
                // Normal: just compile the pattern
                queries.addAll(compileBasicPattern(pattern, rel));
        }

        return new CompiledRelation(rel.getName(), queries, rel.getType());
    }

    /**
     * Compile a basic pattern.
     */
    private List<SpanQuery> compileBasicPattern(CQLParser.ParsedCQL pattern,
                                                 SketchGrammarParser.SketchRelation rel) {
        List<SpanQuery> queries = new ArrayList<>();

        // Main pattern - convert to CQLPattern for compilation
        if (!pattern.getElements().isEmpty()) {
            CQLPattern cqlPattern = new CQLPattern();
            for (CQLPattern.PatternElement elem : pattern.getElements()) {
                cqlPattern.addElement(elem);
            }
            queries.add(cqlCompiler.compile(cqlPattern));

            // Add alternative patterns
            for (String alt : pattern.getAlternatives()) {
                try {
                    CQLPattern altPattern = new CQLParser().parse(alt);
                    queries.add(cqlCompiler.compile(altPattern));
                } catch (Exception e) {
                    // Skip invalid alternatives
                }
            }
        }

        return queries;
    }

    /**
     * Compile pattern with bidirectional expansion for DUAL relations.
     */
    private List<SpanQuery> compilePatternWithExpansion(CQLParser.ParsedCQL pattern,
                                                         SketchGrammarParser.SketchRelation rel,
                                                         boolean includeReverse) {
        List<SpanQuery> queries = compileBasicPattern(pattern, rel);

        if (includeReverse && !pattern.getElements().isEmpty()) {
            // For DUAL, also compile the reverse relation
            // Swap positions 1 and 2 in the pattern
            CQLPattern reversePattern = createReversePattern(pattern);
            queries.add(cqlCompiler.compile(reversePattern));
        }

        return queries;
    }

    /**
     * Create a reversed pattern for bidirectional relations.
     */
    private CQLPattern createReversePattern(CQLParser.ParsedCQL original) {
        // Simple reversal: swap positions 1 and 2
        CQLPattern reverse = new CQLPattern();

        for (CQLPattern.PatternElement elem : original.getElements()) {
            int pos = elem.getPosition();
            if (pos == 1) {
                reverse.addElement(new CQLPattern.PatternElement(2, elem.getTarget(),
                    elem.getConstraint(), elem.getMinRepetition(), elem.getMaxRepetition(),
                    elem.getMinDistance(), elem.getMaxDistance(), elem.getLabel()));
            } else if (pos == 2) {
                reverse.addElement(new CQLPattern.PatternElement(1, elem.getTarget(),
                    elem.getConstraint(), elem.getMinRepetition(), elem.getMaxRepetition(),
                    elem.getMinDistance(), elem.getMaxDistance(), elem.getLabel()));
            } else {
                reverse.addElement(elem);
            }
        }

        return reverse;
    }

    /**
     * Compile a trinary pattern (three-position).
     */
    private List<SpanQuery> compileTrinaryPattern(CQLParser.ParsedCQL pattern,
                                                   SketchGrammarParser.SketchRelation rel) {
        List<SpanQuery> queries = compileBasicPattern(pattern, rel);

        // Trinary patterns need special handling for the third position
        // This is handled during matching in the executor

        return queries;
    }

    /**
     * Compile a unary pattern (single element).
     */
    private List<SpanQuery> compileUnaryPattern(CQLParser.ParsedCQL pattern,
                                                 SketchGrammarParser.SketchRelation rel) {
        List<SpanQuery> queries = compileBasicPattern(pattern, rel);

        // Unary patterns are single-element, like "ADJECTIVE -> adj"
        // They just filter by POS tag

        return queries;
    }

    /**
     * Get compiled queries for a relation.
     */
    public List<SpanQuery> getRelationQueries(String relationName) {
        return compiledRelations.getOrDefault(relationName, new ArrayList<>());
    }

    /**
     * Compiled sketch result.
     */
    public static class CompiledSketch {
        private final List<CompiledRelation> relations;
        private final String defaultAttr;

        public CompiledSketch(List<CompiledRelation> relations, String defaultAttr) {
            this.relations = relations;
            this.defaultAttr = defaultAttr;
        }

        public List<CompiledRelation> getRelations() { return relations; }
        public String getDefaultAttr() { return defaultAttr; }
    }

    /**
     * Compiled relation.
     */
    public static class CompiledRelation {
        private final String name;
        private final List<SpanQuery> queries;
        private final SketchGrammarParser.RelationType type;

        public CompiledRelation(String name, List<SpanQuery> queries, SketchGrammarParser.RelationType type) {
            this.name = name;
            this.queries = queries;
            this.type = type;
        }

        public String getName() { return name; }
        public List<SpanQuery> getQueries() { return queries; }
        public SketchGrammarParser.RelationType getType() { return type; }
        public boolean isEmpty() { return queries.isEmpty(); }
    }
}
